// game_state.cpp
// Routines to manage the current game state
// This file was automatically generated by Spritely 0.6.8 beta

#include <gba_input.h>
#include <gba_video.h>

#include "animation.h"
#include "backgrounds.h"
#include "collision.h"
#include "game_state.h"
#include "object_utils.h"
#include "sprites.h"

// The GameState structure holds all of the global game state information.
GameState _gs;


// InitGameState
// This is called once at the beginning of the game to set up all of the game objects.
void InitGameState() {
	// Initialize the objects.
	InitObject(kObj_Player, kSprite_Paddle);
	InitObject(kObj_Opponent, kSprite_Paddle);
	InitObject(kObj_Ball, kSprite_Ball);

	// Set the initial location fo each object.
	_gs.xPlayer = SCREEN_WIDTH - GetObjectWidth(kObj_Player) - 8;
	_gs.yPlayer = 0;
	MoveObjectTo(kObj_Player, _gs.xPlayer, _gs.yPlayer);
	
	_gs.xOpponent = 8;
	_gs.yOpponent = 0;
	MoveObjectTo(kObj_Opponent, _gs.xOpponent, _gs.yOpponent);
	
	_gs.xBall = SCREEN_WIDTH / 2;
	_gs.yBall = 0;
	MoveObjectTo(kObj_Ball, _gs.xBall, _gs.yBall);
	
	// Initialize the ball direction.
	_gs.dxBall = 1;
	_gs.dyBall = 1;
}

// UpdateGameState
// This is called repeatedly, 60 times per second.
// You check the buttons and update the game state.
void UpdateGameState() {
	// Get the current state of the buttons.
	scanKeys();

	// Get the buttons that have been newly pressed since the last time we
	// called scanKeys().
	//u16 keyDown = keysDown();
	
	// Get the buttons that are currently being pressed (regardless of
	// whether or not we've already handled the button press).
	u16 keyHeld = keysHeld();

	// The arrow keys are used to move the current object.
	// We use kHeld because we want the action to repeat as long as the player is
	// holding down the button.
	int dx = 0;
	int dy = 0;
	//if (keyHeld & KEY_LEFT)
	//	dx = -1;
	//if (keyHeld & KEY_RIGHT)
	//	dx = 1;
	if (keyHeld & KEY_UP)
		dy = -1;
	if (keyHeld & KEY_DOWN)
		dy = 1;

	// If we need to move the player.
	if (dx != 0 || dy != 0) {
		// Move the player to the new location.
		int x = _gs.xPlayer + dx;
		int y = _gs.yPlayer + dy;

		// Get the width/height of the player.
		int width, height;
		GetObjectSize(kObj_Player, &width, &height);

		// Don't let the player go outside the screen boundaries.
		if (x < 0 || x > SCREEN_WIDTH - width)
			dx = 0;
		if (y < 0 || y > SCREEN_HEIGHT - height)
			dy = 0;

		// Record the player's new location.
		_gs.xPlayer += dx;
		_gs.yPlayer += dy;

		// Move the player to the new location.
		MoveObjectTo(kObj_Player, _gs.xPlayer, _gs.yPlayer);
	}
	
	// Check where the ball is moving.
	int x = _gs.xBall + _gs.dxBall;
	int y = _gs.yBall + _gs.dyBall;
	
	// Don't let the ball go off the left/right side of screen.
	if (x<0 || x > SCREEN_WIDTH - GetObjectWidth(kObj_Ball))
		_gs.dxBall *= -1;
	// Don't let the ball go off the top/bottom of screen.
	if (y<0 || y > SCREEN_HEIGHT - GetObjectHeight(kObj_Ball))
		_gs.dyBall *= -1;
	
	// Does the ball collide with a paddle?
	if (CollideBBox(kObj_Player, kObj_Ball))
		_gs.dxBall = -1;
	if (CollideBBox(kObj_Opponent, kObj_Ball))
		_gs.dxBall = 1;
		
	// Move the ball.
	_gs.xBall += _gs.dxBall;
	_gs.yBall += _gs.dyBall;
	MoveObjectTo(kObj_Ball, _gs.xBall, _gs.yBall);
	
	// Handle opponent AI.
	dy = 0;
	// If the ball is above the paddle
	if (_gs.yBall < _gs.yOpponent) {
		// Move the paddle up
		dy = -1;
		// Unless that would move the paddle above the top of the screen
		if (_gs.yOpponent < 0)
			dy = 0;
	} else {
		// Otherwise, move the paddle down
		dy = 1;
		// Unless that would move the paddle below the bottom of the screen
		if (_gs.yOpponent > SCREEN_HEIGHT - GetObjectHeight(kObj_Opponent))
			dy = 0;
	}
	
	// Move the paddle.
	_gs.yOpponent += dy;
	MoveObjectTo(kObj_Opponent, _gs.xOpponent, _gs.yOpponent);
}
